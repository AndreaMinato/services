declare module 'ramda' {
  declare type placeholder = {}
  declare type ListIterator<T, TResult> = {
    (value: T, index: number, list: T[]): TResult;
  }
  declare type ObjectIterator<T, TResult> = {
    (element: T, key: string, obj: Dictionary<T>): Dictionary<TResult>;
  }
  declare type KeyValuePair<K, V> = {
    first : K;
    second : V;
  }
  declare type ArrayLike = {
    nodeType: number;
  }
  declare type Arity0Fn = {
    (): any;
  }
  declare type Arity1Fn = {
    (a: any): any;
  }
  declare type Arity2Fn = {
    (a: any, b: any): any;
  }
  declare type ObjFunc = {
    [index:string]: Function;
  }
  declare type ObjFunc2 = {
    [index:string]: (x: any, y: any) => boolean;
  }
  declare type Pred = {
    (...a: any[]): boolean;
  }
  declare type ObjPred = {
    (value: any, key: string): boolean;
  }
  declare type Dictionary<T> = {
    [index: string]: T;
  }
  declare type CharList = {
    push(x: string): void;
  }
  declare type Lens = {
    <T,U>(obj: T): U;
    set<T,U>(str: string, obj: T): U;
  }
  declare type __= placeholder;
  declare function adjust<T>(fn: (a: T) => T, index: number, list: T[]): T[];
  declare function adjust<T>(fn: (a: T) => T, index: number): (list: T[]) => T[];
  declare function all<T>(fn: (a: T) => boolean, list: T[]): boolean;
  declare function all<T>(fn: (a: T) => boolean): (list: T[]) => boolean;
  declare function any<T>(fn: (a: T) => boolean, list: T[]): boolean;
  declare function any<T>(fn: (a: T) => boolean): (list: T[]) => boolean;
  declare function aperture<T>(n: number, list: T): T[][];
  declare function aperture<T>(n: number): (list: T) => T[][];
  declare function append<T>(el: T, list: T[]): T[];
  declare function append<T>(el: T): (list: T[]) => T[];
  declare function append<T, U>(el: U, list: T[]): (T & U)[];
  declare function append<T, U>(el: U): (list: T[]) => (T & U)[];
  declare function chain<T, U>(fn: (n: T) => U[], list: T[]): U[];
  declare function chain<T, U>(fn: (n: T) => U[]): (list: T[]) => U[];
  declare function commute<T, U>(of: (x: T) => U, list: U[]): U;
  declare function commute<T, U>(of: (x: T) => U): (list: U[]) => U;
  declare function commute<T, U>(of: (x: T) => T[], list: U[]): U[];
  declare function commute<T, U>(of: (x: T) => T[]): (list: U[]) => U[];
  declare function commuteMap<T, U>(fn: (list: T[]) => U[], of: (x: T[]) => U[][], list: T[][]): U[][];
  declare function commuteMap<T, U>(fn: (list: T[]) => U[]): (of: (x: T[]) => U[][], list: T[][]) => U[][];
  declare function commuteMap<T, U>(fn: (list: T[]) => U[], of: (x: T[]) => U[][]): (list: T[][]) => U[][];
  declare function concat<T>(list1: T[], list2: T[]): T[];
  declare function concat<T>(list1: T[]): (list2: T[]) => T[];
  declare function concat<T>(list1: string, list2: string): string;
  declare function concat<T>(list1: string): (list2: string) => string;
  declare function contains<T>(a: T, list: T[]): boolean;
  declare function contains<T>(a: T): (list: T[]) => boolean;
  declare function containsWith<T>(pred: (a: T, b: T) => boolean, x: T, list: T[]): boolean;
  declare function containsWith<T>(pred: (a: T, b: T) => boolean, x: T): (list: T[]) => boolean;
  declare function drop<T>(n: number, list: T[]): T[];
  declare function drop<T>(n: number): (list: T[]) => T[];
  declare function dropWhile<T>(fn: (a: T) => boolean, list: T[]): T[];
  declare function dropWhile<T>(fn: (a: T) => boolean): (list: T[]) => T[];
  declare function filter<T>(fn: (value: T) => boolean): (list: T[]) => T[];
  declare function filter<T>(fn: (value: T) => boolean, list: T[]): T[];
  declare function filterIndexed<T>(fn: (value: T, index: number, list: T[]) => boolean): (list: T[]) => T[];
  declare function filterIndexed<T>(fn: (value: T, index: number, list: T[]) => boolean, list: T[]): T[];
  declare function find<T>(fn: (a: T) => boolean, list: T[]): T;
  declare function find<T>(fn: (a: T) => boolean): (list: T[]) => T;
  declare function findIndex<T>(fn: (a: T) => boolean, list: T[]): number;
  declare function findIndex<T>(fn: (a: T) => boolean): (list: T[]) => number;
  declare function findLast<T>(fn: (a: T) => boolean, list: T[]): T;
  declare function findLast<T>(fn: (a: T) => boolean): (list: T[]) => T;
  declare function findLastIndex<T>(fn: (a: T) => boolean, list: T[]): number;
  declare function findLastIndex<T>(fn: (a: T) => boolean): (list: T[]) => number;
  declare function flatten<T>(x: T[]): T[];
  declare function forEach<T>(fn: (x: T) => void, list: T[]): T[];
  declare function forEach<T>(fn: (x: T) => void): (list: T[]) => T[];
  declare function forEachIndexed<T>(fn: (x: T, idx?: number, list?: T[]) => void, list: T[]): T[];
  declare function forEachIndexed<T>(fn: (x: T, idx?: number, list?: T[]) => void): (list: T[]) => T[];
  declare function fromPairs<V>(pairs: KeyValuePair<string, V>[]): {[index: string]: V};
  declare function fromPairs<V>(pairs: KeyValuePair<number, V>[]): {[index: number]: V};
  declare function groupBy<T>(fn: (a: T) => string, list: T[]): {[index: string]: T[]};
  declare function groupBy<T>(fn: (a: T) => string): <T>(list: T[]) => {[index: string]: T[]};
  declare function head<T>(list: T[]): T;
  declare function indexOf<T>(target: T, list: T[]): number;
  declare function indexOf<T>(target: T): (list: T[]) => number;
  declare function init<T>(list: T[]): T[];
  declare function insert(index: number, elt: any, list: any[]): any[];
  declare function insert(index: number): (elt: any, list: any[]) => any[];
  declare function insert(index: number, elt: any): (list: any[]) => any[];
  declare function insertAll(index: number, elts: any[], list: any[]): any[];
  declare function insertAll(index: number): (elts: any[], list: any[]) => any[];
  declare function insertAll(index: number, elts: any[]): (list: any[]) => any[];
  declare function into<T>(acc: any, xf: Function, list: T[]): T[];
  declare function into<T>(acc: any, xf: Function): (list: T[]) => T[];
  declare function into<T>(acc: any): (xf: Function, list: T[]) => T[];
  declare function isSet(list: any[]): boolean;
  declare function join(x: string, xs: any[]): string;
  declare function join(x: string): (xs: any[]) => string;
  declare function last<T>(list: T[]): T;
  declare function lastIndexOf<T>(target: T, list: T[]): number;
  declare function length(list: any[]): number;
  declare function map<T, U>(fn: (x: T) => U, list: T[]): U[];
  declare function map<T, U>(fn: (x: T) => U): (list: T[]) => U[];
  declare function mapAccum<T, U, TResult>(fn: (acc: U, value: T) => [U, TResult], acc: U, list: T[]): [U, TResult[]];
  declare function mapAccum<T, U, TResult>(fn: (acc: U, value: T) => [U, TResult]): (acc: U, list: T[]) => [U, TResult[]];
  declare function mapAccum<T, U, TResult>(fn: (acc: U, value: T) => [U, TResult], acc: U): (list: T[]) => [U, TResult[]];
  declare function mapAccumRight<T, U, TResult>(fn: (acc: U, value: T) => [U, TResult], acc: U, list: T[]): [U, TResult[]];
  declare function mapAccumRight<T, U, TResult>(fn: (acc: U, value: T) => [U, TResult]): (acc: U, list: T[]) => [U, TResult[]];
  declare function mapAccumRight<T, U, TResult>(fn: (acc: U, value: T) => [U, TResult], acc: U): (list: T[]) => [U, TResult[]];
  declare function mapIndexed<T, U>(fn: (val: T, key: number, list: T[]) => U, list: T[]): U[];
  declare function mapIndexed<T, U>(fn: (val: T, key: number, list: T[]) => U): (list: T[]) => U[];
  declare function mergeAll(list: any[]): any;
  declare function none<T>(fn: (a: T) => boolean, list: T[]): boolean;
  declare function none<T>(fn: (a: T) => boolean): (list: T[]) => boolean;
  declare function nth<T>(n: number, list: T[]): T;
  declare function nth<T>(n: number): (list: T[]) => T;
  declare function partition<T>(fn: (a: T) => boolean, list: T): T[];
  declare function partition<T>(fn: (a: T) => boolean): (list: T) => T[];
  declare function pluck<T>(p: string|number, list: any[]): T[];
  declare function pluck<T>(p: string|number): (list: any[]) => T[];
  declare function pluck(p: string|number, list: any[]): any[];
  declare function pluck(p: string|number): (list: any[]) => any[];
  declare function prepend<T>(el: T, list: T[]): T[];
  declare function prepend<T>(el: T): (list: T[]) => T[];
  declare function range(from: number, to: number): number[];
  declare function range(from: number): (to: number) => number[];
  declare function reduce<T, TResult>(fn: (acc: TResult, elem: T) => TResult, acc: TResult, list: T[]): TResult;
  declare function reduce<T, TResult>(fn: (acc: TResult, elem: T) => TResult): (acc: TResult, list: T[]) => TResult;
  declare function reduce<T, TResult>(fn: (acc: TResult, elem: T) => TResult, acc: TResult): (list: T[]) => TResult;
  declare function reduceIndexed<T, TResult>(fn: (acc: TResult, elem: T, idx: number, list: T[]) => TResult, acc: TResult, list: T[]): TResult;
  declare function reduceIndexed<T, TResult>(fn: (acc: TResult, elem: T, idx: number, list: T[]) => TResult): (acc: TResult, list: T[]) => TResult;
  declare function reduceIndexed<T, TResult>(fn: (acc: TResult, elem: T, idx: number, list: T[]) => TResult, acc: TResult): (list: T[]) => TResult;
  declare function reduceRight<T, TResult>(fn: (acc: TResult, elem: T) => TResult, acc: TResult, list: T[]): TResult;
  declare function reduceRight<T, TResult>(fn: (acc: TResult, elem: T) => TResult): (acc: TResult, list: T[]) => TResult;
  declare function reduceRight<T, TResult>(fn: (acc: TResult, elem: T) => TResult, acc: TResult): (list: T[]) => TResult;
  declare function reduceRightIndexed<T, TResult>(fn: (acc: TResult, elem: T, idx: Number, list: T[]) => TResult, acc: TResult, list: T[]): TResult;
  declare function reduceRightIndexed<T, TResult>(fn: (acc: TResult, elem: T, idx: Number, list: T[]) => TResult): (acc: TResult, list: T[]) => TResult;
  declare function reduceRightIndexed<T, TResult>(fn: (acc: TResult, elem: T, idx: Number, list: T[]) => TResult, acc: TResult): (list: T[]) => TResult;
  declare function reject<T>(fn: (value: T) => boolean, list: T[]): T[];
  declare function reject<T>(fn: (value: T) => boolean): (list: T[]) => T[];
  declare function rejectIndexed<T>(fn: (value: T, index: number, list: T[]) => boolean, list: T[]): T[];
  declare function rejectIndexed<T>(fn: (value: T, index: number, list: T[]) => boolean): (list: T[]) => T[];
  declare function remove<T>(start: number, count: number, list: T[]): T[];
  declare function remove<T>(start: number): (count: number, list: T[]) => T[];
  declare function remove<T>(start: number, count: number): (list: T[]) => T[];
  declare function repeat<T>(a: T, n: number): T[];
  declare function repeat<T>(a: T): (n: number) => T[];
  declare function reverse<T>(list: T[]): T[];
  declare function scan<T, TResult>(fn: (acc: TResult, elem: T) => TResult, acc: TResult, list: T[]): TResult;
  declare function scan<T, TResult>(fn: (acc: TResult, elem: T) => TResult): (acc: TResult, list: T[]) => TResult;
  declare function scan<T, TResult>(fn: (acc: TResult, elem: T) => TResult, acc: TResult): (list: T[]) => TResult;
  declare function slice(a: number, b: number, list: string): string;
  declare function slice<T>(a: number, b: number, list: T[]): T[];
  declare function slice<T>(a: number, b: number): (list: string|T[]) => string|T[];
  declare function slice<T>(a: number): (b: number, list: string|T[]) => string|T[];
  declare function sort<T>(fn: (a: T, b: T) => number, list: T[]): T[];
  declare function sort<T>(fn: (a: T, b: T) => number): (list: T[]) => T[];
  declare function splitEvery<T>(a: number, list: T[]): T[][];
  declare function splitEvery<T>(a: number): (list: T[]) => T[][];
  declare function tail<T>(list: T[]): T[];
  declare function take<T>(n: number, list: T[]): T[];
  declare function take<T>(n: number): (list: T[]) => T[];
  declare function takeWhile<T>(fn: (x: T) => boolean, list: T[]): T[];
  declare function takeWhile<T>(fn: (x: T) => boolean): (list: T[]) => T[];
  declare function times<T>(fn: (i: number) => T, n: number): T[];
  declare function times<T>(fn: (i: number) => T): (n: number) => T[];
  declare function transduce<T,U>(xf: (arg: T[]) => T[], fn: (acc: U[], val: U) => U[], acc: T[], list: T[]): U;
  declare function transduce<T,U>(xf: (arg: T[]) => T[]): (fn: (acc: U[], val: U) => U[], acc: T[], list: T[]) => U;
  declare function transduce<T,U>(xf: (arg: T[]) => T[], fn: (acc: U[], val: U) => U[]): (acc: T[], list: T[]) => U;
  declare function transduce<T,U>(xf: (arg: T[]) => T[], fn: (acc: U[], val: U) => U[], acc: T[]): (list: T[]) => U;
  declare function unfold<T, TResult>(fn: (seed: T) => TResult, seed: T): TResult[];
  declare function unfold<T, TResult>(fn: (seed: T) => TResult): (seed: T) => TResult[];
  declare function uniq<T>(list: T[]): T[];
  declare function uniqBy<T,U>(fn: (a: T) => U, list: T[]): T[];
  declare function uniqBy<T,U>(fn: (a: T) => U): (list: T[]) => T[];
  declare function uniqWith<T,U>(pred: (x: T, y: T) => boolean, list: T[]): T[];
  declare function uniqWith<T,U>(pred: (x: T, y: T) => boolean): (list: T[]) => T[];
  declare function unnest<T>(x: T[]): T[];
  declare function update<T>(index: number, value: T, list: T[]): T[];
  declare function update<T>(index: number, value: T): (list: T[]) => T[];
  declare function xprod<K,V>(as: K[], bs: V[]): KeyValuePair<K,V>[];
  declare function xprod<K,V>(as: K[]): (bs: V[]) => KeyValuePair<K,V>[];
  declare function zip<K,V>(list1: K[], list2: V[]): KeyValuePair<K,V>[];
  declare function zip<K,V>(list1: K[]): (list2: V[]) => KeyValuePair<K,V>[];
  declare function zipObj<T>(keys: string[], values: T[]): {[index:string]: T};
  declare function zipObj<T>(keys: string[]): (values: T[]) => {[index:string]: T};
  declare function zipWith<T, U, TResult>(fn: (x: T, y: U) => TResult, list1: T[], list2: U[]): TResult[];
  declare function zipWith<T, U, TResult>(fn: (x: T, y: U) => TResult, list1: T[]): (list2: U[]) => TResult[];
  declare function zipWith<T, U, TResult>(fn: (x: T, y: U) => TResult): (list1: T[], list2: U[]) => TResult[];
  declare function assoc(prop: string, val: any, obj: any): any;
  declare function assoc(prop: string): (val: any, obj: any) => any;
  declare function assoc(prop: string, val: any): (obj: any) => any;
  declare function assocPath(path: string[], val: any, obj: any): any;
  declare function assocPath(path: string[]): (val: any, obj: any) => any;
  declare function assocPath(path: string[], val: any): (obj: any) => any;
  declare function clone(value: any): any;
  declare function clone(value: any[]): any[];
  declare function createMapEntry<T>(key: string, val: T): {[index: string]: T};
  declare function createMapEntry<T>(key: placeholder, val: T): (key: string) => {[index: string]: T};
  declare function createMapEntry<T>(key: string): (val: T) => {[index: string]: T};
  declare function dissoc(prop: string, obj: any): any;
  declare function dissoc(prop: string): (obj: any) => any;
  declare function dissoc(prop: string, obj: any): any;
  declare function dissoc(prop: placeholder, obj: any): (prop: string) => any;
  declare function dissoc(prop: string): (obj: any) => any;
  declare function dissocPath(path: string[], obj: any): any;
  declare function dissocPath(path: string[]): (obj: any) => any;
  declare function eqProps(prop: string, obj1: any, obj2: any): boolean;
  declare function eqProps(prop: string): (obj1: any, obj2: any) => boolean;
  declare function eqProps(prop: string, obj1: any): (obj2: any) => boolean;
  declare function evolve(transformations: {[index: string]: (value: any) => any}, obj: any): any;
  declare function functions(obj: any): string[];
  declare function functionsIn(obj: any): string[];
  declare function has(s: string, obj: any): boolean;
  declare function has(s: string): (obj: any) => boolean;
  declare function has(s: placeholder, obj: any): (a: string) => boolean;
  declare function hasIn(s: string, obj: any): boolean;
  declare function hasIn(s: string): (obj: any) => boolean;
  declare function hasIn(s: placeholder, obj: any): (a: string) => boolean;
  declare function invert(obj: any): {[index:string]: string[]};
  declare function invertObj(obj: any): {[index:string]: string};
  declare function invertObj(obj: {[index: number]: string}): {[index:string]: string};
  declare function keys(x: any): string[];
  declare function keysIn(obj: any): string[];
  declare function lens<T,U,V>(getter: (s: T) => U, setter: (a: U, s: T) => V): Lens;
  declare function lensIndex(n: number): Lens;
  declare function lensProp(str: string): {
    <T, U>(obj: T): U;
    set<T,U,V>(val: T, obj: U): V;
  };
  declare function mapObj<T, TResult>(fn: (value: T) => TResult, obj: any): {[index: string]: TResult};
  declare function mapObj<T, TResult>(fn: (value: T) => TResult): (obj: any) => {[index: string]: TResult};
  declare function mapObjIndexed<T, TResult>(fn: (value: T, key: string, obj?: any) => TResult, obj: any): {[index:string]: TResult};
  declare function mapObjIndexed<T, TResult>(fn: (value: T, key: string, obj?: any) => TResult): (obj: any) => {[index:string]: TResult};
  declare function merge(a: any, b: any): any;
  declare function merge(a: any): (b: any) => any;
  declare function omit<T>(names: string[], obj: T): T;
  declare function omit<T>(names: string[]): (obj: T) => T;
  declare function over<T>(lens: Lens, fn: Arity1Fn, value: T|T[]): T|T[];
  declare function over<T>(lens: Lens, fn: Arity1Fn): (value: T|T[]) => T|T[];
  declare function over<T>(lens: Lens): (fn: Arity1Fn, value: T|T[]) => T|T[];
  declare function path<T>(path: string[], obj: any): T;
  declare function path<T>(path: placeholder, obj: any): (path: string[]) => T;
  declare function path<T>(path: string[]): (obj: any) => T;
  declare function pick<T>(names: string[], obj: T): T;
  declare function pick<T>(names: string[]): (obj: T) => T;
  declare function pickAll<T, U>(names: string[], obj: T): U;
  declare function pickAll<T, U>(names: string[]): (obj: T) => U;
  declare function pickBy<T,U>(pred: ObjPred, obj: T): U;
  declare function pickBy<T,U>(pred: ObjPred): (obj: T) => U;
  declare function project<T,U>(props: string[], objs: T[]): U[];
  declare function prop<T>(p: string, obj: any): T;
  declare function prop<T>(p: string): (obj: any) => T;
  declare function propOr<T,U,V>(val: T, p: string, obj: U): V;
  declare function propOr<T,U,V>(val: T, p: string): (obj: U) => V;
  declare function propOr<T,U,V>(val: T): (p: string, obj: U) => V;
  declare function props<T>(ps: string[], obj: Dictionary<T>): T[];
  declare function props<T>(ps: string[]): (obj:  Dictionary<T>) => T[];
  declare function set<T,U>(lens: Lens, a: U, obj: T): T;
  declare function set<T,U>(lens: Lens, a: U): (obj: T) => T;
  declare function set<T,U>(lens: Lens): (a: U, obj: T) => T;
  declare function toPairs(obj: any): any[][];
  declare function toPairsIn(obj: any): any[][];
  declare function values<T>(obj: {[index: string]: T}): T[];
  declare function values(obj: any): any[];
  declare function valuesIn(obj: any): any[];
  declare function view<T,U>(lens: Lens, obj: T): U;
  declare function where<T,U>(spec: T, testObj: U): boolean;
  declare function where<T,U>(spec: T): (testObj: U) => boolean;
  declare function where<ObjFunc2,U>(spec: ObjFunc2, testObj: U): boolean;
  declare function where<ObjFunc2,U>(spec: ObjFunc2): (testObj: U) => boolean;
  declare function whereEq<T,U>(spec: T, obj: U): boolean;
  declare function whereEq<T,U>(spec: T): (obj: U) => boolean;
  declare function addIndex<T, U>(fn: (f: (item: T) => U, list: T[]) => U[]): (fn: (item: T, idx: number, list?: T[]) => U) => (list: T[]) => U[];
  declare function addIndex<T, U>(fn: (f: (item: T) => U, list: T[]) => U[]): (fn: (item: T, idx: number, list?: T[]) => U, list: T[]) => U[];
  declare function always<T>(val: T): () => T;
  declare function ap<T,U>(fns: ((a: T) => U)[], vs: T[]): U[];
  declare function ap<T,U>(fns: ((a: T) => U)[]): (vs: T[]) => U[];
  declare function apply<T, U, TResult>(fn: (arg0: T, ...args: T[]) => TResult, args: U[]): TResult;
  declare function apply<T, U, TResult>(fn: (arg0: T, ...args: T[]) => TResult): (args: U[]) => TResult;
  declare function binary(fn: (...args: any[]) => any): Function;
  declare function bind<T>(thisObj: T, fn: (...args: any[]) => any): (...args: any[]) => any;
  declare function call(fn: (...args: any[])=> (...args: any[]) => any, ...args: any[]): any;
  declare function comparator<T>(pred: (a: T, b: T) => boolean): (x: T, y: T) => number;
  declare function compose<V0, T1>(fn0: (x0: V0) => T1): (x0: V0) => T1;
  declare function compose<V0, V1, T1>(fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T1;
  declare function compose<V0, V1, V2, T1>(fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T1;
  declare function compose<V0, T1, T2>(fn1: (x: T1) => T2, fn0: (x0: V0) => T1): (x0: V0) => T2;
  declare function compose<V0, V1, T1, T2>(fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T2;
  declare function compose<V0, V1, V2, T1, T2>(fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T2;
  declare function compose<V0, T1, T2, T3>(fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x: V0) => T1): (x: V0) => T3;
  declare function compose<V0, V1, T1, T2, T3>(fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T3;
  declare function compose<V0, V1, V2, T1, T2, T3>(fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T3;
  declare function compose<V0, T1, T2, T3, T4>(fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x: V0) => T1): (x: V0) => T4;
  declare function compose<V0, V1, T1, T2, T3, T4>(fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T4;
  declare function compose<V0, V1, V2, T1, T2, T3, T4>(fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T4;
  declare function compose<V0, T1, T2, T3, T4, T5>(fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x: V0) => T1): (x: V0) => T5;
  declare function compose<V0, V1, T1, T2, T3, T4, T5>(fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T5;
  declare function compose<V0, V1, V2, T1, T2, T3, T4, T5>(fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T5;
  declare function compose<V0, T1, T2, T3, T4, T5, T6>(fn5: (x: T5) => T6, fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x: V0) => T1): (x: V0) => T6;
  declare function compose<V0, V1, T1, T2, T3, T4, T5, T6>(fn5: (x: T5) => T6, fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T6;
  declare function compose<V0, V1, V2, T1, T2, T3, T4, T5, T6>(fn5: (x: T5) => T6, fn4: (x: T4) => T5, fn3: (x: T3) => T4, fn2: (x: T2) => T3, fn1: (x: T1) => T2, fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T6;
  declare function construct(fn: Function): Function;
  declare function constructN(n: number, fn: Function): Function;
  declare function converge(after: Function, fns: Function[]): Function;
  declare function curry<T1, T2, TResult>(fn: (a: T1, b: T2) => TResult): (a: T1) => (b: T2) => TResult;
  declare function curry<T1, T2, T3, TResult>(fn: (a: T1, b: T2, c: T3) => TResult): (a: T1) => (b: T2) => (c: T3) => TResult;
  declare function curry<T1, T2, T3, T4, TResult>(fn: (a: T1, b: T2, c: T3, d: T4) => TResult): (a: T1) => (b: T2) => (c: T3) => (d: T4) => TResult;
  declare function curry<T1, T2, T3, T4, T5, TResult>(fn: (a: T1, b: T2, c: T3, d: T4, e: T5) => TResult): (a: T1) => (b: T2) => (c: T3) => (d: T4) => (e: T5) => TResult;
  declare function curry<T1, T2, T3, T4, T5, T6, TResult>(fn: (a: T1, b: T2, c: T3, d: T4, e: T5, f: T6) => TResult): (a: T1) => (b: T2) => (c: T3) => (d: T4) => (e: T5) => (f: T6) => TResult;
  declare function curry(fn: Function): Function;
  declare function curryN(length: number, fn: (...args: any[]) => any): Function;
  declare function empty(x: any): any[];
  declare function F(): boolean;
  declare function flip<T,U,TResult>(fn: (arg0: T, arg1: U) => TResult): (arg1: U, arg0?: T) => TResult;
  declare function flip<T,U,TResult>(fn: (arg0: T, arg1: U, ...args: any[]) => TResult): (arg1: U, arg0?: T, ...args: any[]) => TResult;
  declare function identity(a: any): any;
  declare function invoker(name: string, obj: any, len?: number): Function;
  declare function lift(fn: Function, ...args: any[]): any;
  declare function liftN(n: number, fn: Function, ...args: any[]): any;
  declare function memoize(fn: Function): Function;
  declare function nAry(n: number, fn: (...arg: any[]) => any): Function;
  declare function of<T>(x: T): T[];
  declare function of<T>(x: T[]): T[][];
  declare function once(fn: Function): Function;
  declare function partial(fn: Function, ...args: any[]): Function;
  declare function partialRight(fn: Function, ...args: any[]): Function;
  declare function pipe<V0, T1>(fn0: (x0: V0) => T1): (x0: V0) => T1;
  declare function pipe<V0, V1, T1>(fn0: (x0: V0, x1: V1) => T1): (x0: V0, x1: V1) => T1;
  declare function pipe<V0, V1, V2, T1>(fn0: (x0: V0, x1: V1, x2: V2) => T1): (x0: V0, x1: V1, x2: V2) => T1;
  declare function pipe<V0, T1, T2>(fn0: (x0: V0) => T1, fn1: (x: T1) => T2): (x0: V0) => T2;
  declare function pipe<V0, V1, T1, T2>(fn0: (x0: V0, x1: V1) => T1, fn1: (x: T1) => T2): (x0: V0, x1: V1) => T2;
  declare function pipe<V0, V1, V2, T1, T2>(fn0: (x0: V0, x1: V1, x2: V2) => T1, fn1: (x: T1) => T2): (x0: V0, x1: V1, x2: V2) => T2;
  declare function pipe<V0, T1, T2, T3>(fn0: (x: V0) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3): (x: V0) => T3;
  declare function pipe<V0, V1, T1, T2, T3>(fn0: (x0: V0, x1: V1) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3): (x0: V0, x1: V1) => T3;
  declare function pipe<V0, V1, V2, T1, T2, T3>(fn0: (x0: V0, x1: V1, x2: V2) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3): (x0: V0, x1: V1, x2: V2) => T3;
  declare function pipe<V0, T1, T2, T3, T4>(fn0: (x: V0) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4): (x: V0) => T4;
  declare function pipe<V0, V1, T1, T2, T3, T4>(fn0: (x0: V0, x1: V1) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4): (x0: V0, x1: V1) => T4;
  declare function pipe<V0, V1, V2, T1, T2, T3, T4>(fn0: (x0: V0, x1: V1, x2: V2) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4): (x0: V0, x1: V1, x2: V2) => T4;
  declare function pipe<V0, T1, T2, T3, T4, T5>(fn0: (x: V0) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5): (x: V0) => T5;
  declare function pipe<V0, V1, T1, T2, T3, T4, T5>(fn0: (x0: V0, x1: V1) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5): (x0: V0, x1: V1) => T5;
  declare function pipe<V0, V1, V2, T1, T2, T3, T4, T5>(fn0: (x0: V0, x1: V1, x2: V2) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5): (x0: V0, x1: V1, x2: V2) => T5;
  declare function pipe<V0, T1, T2, T3, T4, T5, T6>(fn0: (x: V0) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5, fn5: (x: T5) => T6): (x: V0) => T6;
  declare function pipe<V0, V1, T1, T2, T3, T4, T5, T6>(fn0: (x0: V0, x1: V1) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5, fn5: (x: T5) => T6): (x0: V0, x1: V1) => T6;
  declare function pipe<V0, V1, V2, T1, T2, T3, T4, T5, T6>(fn0: (x0: V0, x1: V1, x2: V2) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5, fn5: (x: T5) => T6): (x0: V0, x1: V1, x2: V2) => T6;
  declare function pipe<V0, T1, T2, T3, T4, T5, T6, T7>(fn0: (x: V0) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5, fn5: (x: T5) => T6, fn: (x: T6) => T7): (x: V0) => T7;
  declare function pipe<V0, V1, T1, T2, T3, T4, T5, T6, T7>(fn0: (x0: V0, x1: V1) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5, fn5: (x: T5) => T6, fn6: (x: T6) => T7): (x0: V0, x1: V1) => T7;
  declare function pipe<V0, V1, V2, T1, T2, T3, T4, T5, T6, T7>(fn0: (x0: V0, x1: V1, x2: V2) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5, fn5: (x: T5) => T6, fn6: (x: T6) => T7): (x0: V0, x1: V1, x2: V2) => T7;
  declare function pipe<V0, T1, T2, T3, T4, T5, T6, T7, T8>(fn0: (x: V0) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5, fn5: (x: T5) => T6, fn6: (x: T6) => T7, fn: (x: T7) => T8): (x: V0) => T8;
  declare function pipe<V0, V1, T1, T2, T3, T4, T5, T6, T7, T8>(fn0: (x0: V0, x1: V1) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5, fn5: (x: T5) => T6, fn6: (x: T5) => T6, fn7: (x: T7) => T8): (x0: V0, x1: V1) => T8;
  declare function pipe<V0, V1, V2, T1, T2, T3, T4, T5, T6, T7, T8>(fn0: (x0: V0, x1: V1, x2: V2) => T1, fn1: (x: T1) => T2, fn2: (x: T2) => T3, fn3: (x: T3) => T4, fn4: (x: T4) => T5, fn5: (x: T5) => T6, fn6: (x: T5) => T6, fn7: (x: T7) => T8): (x0: V0, x1: V1, x2: V2) => T8;
  declare function tap<T>(fn: (a: T) => any, value: T): T;
  declare function tap<T>(fn: (a: T) => any): (value: T) => T;
  declare function op(fn: (a: any, b: any) => any): Function;
  declare function substring(indexA: number, indexB: number, str: string): string;
  declare function substringFrom(indexA: number, str: string): string;
  declare function substringTo(indexA: number, str: string): string;
  declare function isArrayLike(val: any): boolean;
  declare function op(fn: Function): Function;
  declare function unary<T>(fn: (a: T, ...args: any[]) => any): (a: T) => any;
  declare function useWith(fn: Function, transformers: Function[]): Function;
  declare function repeatN<T>(value: T, n: number): T[];
  declare function wrap(fn: Function, wrapper: Function): Function;
  declare function of(x: any): any[];
  declare function flatten(x: any[]): any[];
  declare function func(funcName: string , obj: any): any;
  declare function installTo(obj: any): any;
  declare function is(ctor: any, val: any): boolean;
  declare function is(ctor: any): (val: any) => boolean;
  declare function isNil(value: any): boolean;
  declare function alwaysZero(): number;
  declare function alwaysFalse(): boolean;
  declare function alwaysTrue(): boolean;
  declare function allPass(preds: Pred[]): Pred;
  declare function and<T>(fn1: T, val2: boolean|any): boolean;
  declare function and<T>(fn1: T): (val2: boolean|any) => boolean;
  declare function anyPass(preds: Pred[]): Pred;
  declare function both(pred1: Pred, pred2: Pred): Pred;
  declare function both(pred1: Pred): (pred2: Pred) => Pred;
  declare function complement(pred: (...args: any[]) => boolean): (...args: any[]) => boolean;
  declare function cond(fns: [Pred, Function][]): Function;
  declare function defaultTo<T,U>(a: T, b: U): T|U;
  declare function defaultTo<T>(a: T): <U>(b: U) => T|U;
  declare function either(pred1: Pred, pred2: Pred): Pred;
  declare function either(pred1: Pred): (pred2: Pred) => Pred;
  declare function ifElse(fn: Pred, onTrue: Arity1Fn, onFalse: Arity1Fn): Arity1Fn;
  declare function isEmpty(value: string|any[]): boolean;
  declare function not(value: any): boolean;
  declare function or<T, U>(a: T, b: U): T|U;
  declare function or<T>(a: T): <U>(b: U) => T|U;
  declare function or<T, U>(fn1: T, val2: U): T|U;
  declare function or<T>(fn1: T): <U>(val2: U) => T|U;
  declare function add(a: number, b: number): number;
  declare function add(a: string, b: string): string;
  declare function add(a: number): (b: number) => number;
  declare function add(a: string): (b: string) => string;
  declare function dec(n: number): number;
  declare function divide(a: number, b: number): number;
  declare function divide(a: number): (b: number) => number;
  declare function divide(a: placeholder, b: number): (b: number) => number;
  declare function gt(a: number, b: number): boolean;
  declare function gt(a: number): (b: number) => boolean;
  declare function gt(a: placeholder, b: number): (b: number) => boolean;
  declare function gte(a: number, b: number): boolean;
  declare function gte(a: number): (b: number) => boolean;
  declare function gte(a: placeholder, b: number): (b: number) => boolean;
  declare function inc(n: number): number;
  declare function isNaN(x: any): boolean;
  declare function lt(a: number, b: number): boolean;
  declare function lt(a: number): (b: number) => boolean;
  declare function lt(a: placeholder, b: number): (b: number) => boolean;
  declare function lte(a: number, b: number): boolean;
  declare function lte(a: number): (b: number) => boolean;
  declare function lte(a: placeholder, b: number): (b: number) => boolean;
  declare function mathMod(a: number, b: number): number;
  declare function mathMod(a: number): (b: number) => number;
  declare function mathMod(a: placeholder, b: number): (a: number) => number;
  declare function max(a: number, b: number): number;
  declare function max(a: number): (b: number) => number;
  declare function maxBy<T>(keyFn: (a: T) => number, list: T[]): T;
  declare function maxBy<T>(keyFn: (a: T) => number): (list: T[]) => T;
  declare function min(a: number, b: number): number;
  declare function min(a: number): (b: number) => number;
  declare function minBy<T>(keyFn: (a: T) => number, list: T[]): T;
  declare function minBy<T>(keyFn: (a: T) => number): (list: T[]) => T;
  declare function modulo(a: number, b: number): number;
  declare function modulo(a: placeholder, b: number): (a: number) => number;
  declare function modulo(a: number): (b: number) => number;
  declare function multiply(a: number, b: number): number;
  declare function multiply(a: number): (b: number) => number;
  declare function multiply(a: placeholder, b: number): (a: number) => number;
  declare function negate(n: number): number;
  declare function product(list: number[]): number;
  declare function subtract(a: number, b: number): number;
  declare function subtract(a: placeholder, b: number): (a: number) => number;
  declare function subtract(a: number): (b: number) => number;
  declare function sum(list: number[]): number;
  declare function substring(indexA: number, indexB: number, str: string): string;
  declare function substring(indexA: number): (indexB: number, str: string) => string;
  declare function substring(indexA: number, indexB: number): (str: string) => string;
  declare function substringFrom(indexA: number, str: string): string;
  declare function substringFrom(indexA: number): (str: string) => string;
  declare function replace(pattern: RegExp, replacement: string, str: string): string;
  declare function replace(pattern: RegExp, replacement: string): (str: string) => string;
  declare function replace(pattern: RegExp): (replacement: string) => (str: string) => string;
  declare function replace(pattern: String, replacement: string, str: string): string;
  declare function replace(pattern: String, replacement: string): (str: string) => string;
  declare function replace(pattern: String): (replacement: string) => (str: string) => string;
  declare function substringTo(toIndex: number, str: string): string;
  declare function substringTo(toIndex: number): (str: string) => string;
  declare function nthChar(index: number, str: string): string;
  declare function nthCharCode(index: number, str: string): number;
  declare function match(regexp: RegExp, str: string): any[];
  declare function strIndexOf(c: string, str: string): number;
  declare function strLastIndexOf(c: string, str: string): number;
  declare function toUpper(str: string): string;
  declare function trim(str: string): string;
  declare function toLower(str: string): string;
  declare function split(sep: string): (str: string) => string[];
  declare function split(sep: RegExp): (str: string) => string[];
  declare function split(sep: string, str: string): string[];
  declare function split(sep: RegExp, str: string): string[];
  declare function countBy(fn: (a: any) => string|number, list: any[]): any;
  declare function countBy(fn: (a: any) => string|number): (list: any[]) => any;
  declare function difference<T>(list1: T[], list2: T[]): T[];
  declare function difference<T>(list1: T[]): (list2: T[]) => T[];
  declare function differenceWith<T>(pred: (a: T, b: T) => boolean, list1: T[], list2: T[]): T[];
  declare function eq<T>(a: T, b: T): boolean;
  declare function eq<T>(a: T): (b: T) => boolean;
  declare function equals<T>(a: T, b: T): boolean;
  declare function equals<T>(a: T): (b: T) => boolean;
  declare function identical<T>(a: T, b: T): boolean;
  declare function identical<T>(a: T): (b: T) => boolean;
  declare function intersection<T>(list1: T[], list2: T[]): T[];
  declare function intersectionWith<T>(pred: (a: T, b: T) => boolean, list1: T[], list2: T[]): T[];
  declare function pathEq(path: string[], val: any, obj: any): boolean;
  declare function pathEq(path: string[], val: any): (obj: any) => boolean;
  declare function pathEq(path: string[]): (val: any, obj: any) => boolean;
  declare function pathEq(path: string[]): (val: any) => (obj: any) => boolean;
  declare function propEq<T>(name: string, val: T, obj: any): boolean;
  declare function propEq<T>(name: number, val: T, obj: any): boolean;
  declare function propEq<T>(name: string, val: T): (...args: any[]) => boolean;
  declare function propEq<T>(name: number, val: T): (...args: any[]) => boolean;
  declare function propEq<T>(name: string): (val: T, ...args: any[]) => boolean;
  declare function propEq<T>(name: number): (val: T, ...args: any[]) => boolean;
  declare function sortBy<T>(fn: (a: any) => string, list: T[]): T[];
  declare function sortBy<T>(__: placeholder, list: T[]): T[];
  declare function sortBy<T>(fn: (a: any) => string): (list: T[]) => T[];
  declare function union<T>(as: T[], bs: T[]): T[];
  declare function unionWith<T>(pred: (a: T, b: T) => boolean, list1: T[], list2: T[]): T[];
  declare function eq<T,U>(a: T, b: U): boolean;
  declare function T(): boolean;
}
